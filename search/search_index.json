{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portafolio de evidencias Javier vega","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Portafolio Ibero    theme: Sistemas Embebidos       name: material</li> </ol>"},{"location":"Proyectos4/RANA/","title":"RANA","text":"<p>#Proyecto RANA  La contaminaci\u00f3n de lagos, estanques y peque\u00f1os cuerpos de agua es un problema creciente que afecta tanto al medio ambiente como a las comunidades locales. La acumulaci\u00f3n de basura pl\u00e1stica, hojas y residuos org\u00e1nicos provoca da\u00f1os en la biodiversidad, genera malos olores y dificulta el acceso al agua para fines recreativos o agr\u00edcolas.</p> <p>La limpieza manual de estos espacios resulta complicada y poco eficiente, por lo que surge la necesidad de soluciones accesibles, aut\u00f3nomas y adaptadas a estos entornos. Este proyecto propone el dise\u00f1o de un robot acu\u00e1tico de navegaci\u00f3n asistida, capaz de recolectar residuos flotantes de forma econ\u00f3mica, sustentable y escalable</p> <p>Presentaci\u00f3n RANA:</p> <p>Descargar especificaci\u00f3n (PDF)</p> <p>Descargar el documento (PDF)</p>"},{"location":"Proyectos4/RANA/#marco-real-ganar-vale-la-pena-aplicado-a-rana","title":"Marco \u201creal-ganar-vale la pena\u201d aplicado a RANA","text":"<p>Descargar especificaci\u00f3n (PDF)</p> <p>Descargar el documento (PDF)</p> <p></p>"},{"location":"Proyectos4/RANA/#modelo-de-canvas","title":"Modelo de canvas","text":"Categor\u00eda Descripci\u00f3n Socios Clave - Compa\u00f1eros y profesores que nos ayuden a mejorar el dise\u00f1o.   - Laboratorios de la universidad donde podamos probar el robot.   - Proveedores de piezas b\u00e1sicas (motores, sensores, paneles solares peque\u00f1os).   - Comunidades que nos permitan probar el robot en estanques peque\u00f1os. Actividades Clave - Dise\u00f1ar y armar el prototipo.   - Probarlo en agua para evaluar limpieza.   - Instalar sensores b\u00e1sicos.   - Dar mantenimiento y ajustar dise\u00f1o.   - Difundir el proyecto en redes o carteles. Propuesta de Valor - Robot econ\u00f3mico y f\u00e1cil de usar.   - Funciona aut\u00f3nomo o con control remoto.   - Mide par\u00e1metros b\u00e1sicos del agua.   - Limpia peque\u00f1as \u00e1reas y genera conciencia ambiental. Relaci\u00f3n con Clientes - Ense\u00f1ar a usar el robot.   - Pedir retroalimentaci\u00f3n.   - Colaborar con grupos ambientales. Segmentos de Clientes - Universidades o laboratorios.   - Comunidades con estanques.   - Grupos estudiantiles ambientales. Recursos Clave - Arduino, sensores, motores, bater\u00edas.   - Taller o laboratorio.   - T\u00fa y tus compa\u00f1eros.   - Materiales reciclables o econ\u00f3micos. Canales - Presentaciones en la universidad.   - Redes sociales.   - Ferias estudiantiles de innovaci\u00f3n. Estructura de Costos - Compra de componentes b\u00e1sicos.   - Ensamblaje y pruebas.   - Materiales de difusi\u00f3n. Fuentes de Ingreso - Apoyo de la universidad o becas.   - Premios en concursos estudiantiles.   - Posible venta a laboratorios o grupos estudiantiles."},{"location":"Proyectos4/RANA/#ideo-business-blueprint","title":"IDEO Business Blueprint","text":"Categor\u00eda Respuesta Clientes - Universidades o laboratorios que quieran investigar calidad del agua. - Comunidades o familias con estanques peque\u00f1os que necesiten limpieza ocasional. - Grupos estudiantiles o ONGs ambientales interesados en prototipos ecol\u00f3gicos. Oferta - Robot acu\u00e1tico peque\u00f1o, f\u00e1cil de armar y operar, que limpia basura flotante en lagos o estanques. - Incluye opci\u00f3n de monitoreo b\u00e1sico del agua con sensores sencillos. Modelo de ingresos y precio - Apoyo de la universidad o becas para proyectos. - Participaci\u00f3n en concursos de innovaci\u00f3n. - Venta de prototipos a otros grupos estudiantiles o laboratorios por precios simb\u00f3licos para cubrir costos de materiales. Canales - Presentaciones en la universidad. - Redes sociales o blog del proyecto. - Ferias estudiantiles de innovaci\u00f3n o medio ambiente. - Contacto directo con laboratorios o grupos ambientales para pruebas y demostraciones. Propuesta de valor - Limpieza de basura flotante en lagos y estanques peque\u00f1os de manera econ\u00f3mica y sencilla. - Monitoreo b\u00e1sico de calidad del agua para investigaci\u00f3n o conciencia ambiental. - F\u00e1cil de usar y mantener, ideal para proyectos estudiantiles o comunidades con recursos limitados. Costos - Componentes electr\u00f3nicos b\u00e1sicos: Arduino/Raspberry, motores, sensores, bater\u00edas. - Materiales para flotadores y estructura del robot. - Tiempo de ensamblaje, pruebas y ajustes del prototipo. - Materiales de difusi\u00f3n o capacitaci\u00f3n (carteles, redes sociales, presentaciones). Socios - Profesores y compa\u00f1eros que asesoren el dise\u00f1o y pruebas. - Laboratorios universitarios para construcci\u00f3n y testeo. - Proveedores de piezas accesibles. - Comunidades que permitan probar el robot en sus estanques. Equipo y recursos - Habilidades: mec\u00e1nica, electr\u00f3nica, programaci\u00f3n b\u00e1sica, dise\u00f1o de prototipos. - Recursos: Arduino o Raspberry Pi, sensores simples, motores, bater\u00edas, taller o laboratorio, herramientas b\u00e1sicas. - Equipo humano: t\u00fa y tus compa\u00f1"},{"location":"Proyectos4/RANA/#creando-valor-rana-robot-acuatico-de-navegacion-asistida","title":"Creando Valor \u2014 RANA (Robot Acu\u00e1tico de Navegaci\u00f3n Asistida)","text":"INSIGHTFUL (Necesidades reales) UNIQUE (Dif\u00edcil de replicar) TARGETED (Cliente apasionado) Limpieza frecuente y segura de lagos/canales urbanos. Navegaci\u00f3n asistida: rumbo estable, retorno seguro y *anticolisi\u00f3n. *Municipios/organismos de agua con presi\u00f3n por quejas vecinales. Datos verificables para justificar presupuesto (kg, m\u00b2, turbidez). Operaci\u00f3n data-first con reportes autom\u00e1ticos y mapas de calor de basura. Direcciones de Parques/Servicios P\u00fablicos responsables de imagen y sanidad. Respuesta r\u00e1pida post-lluvias y en temporadas altas de residuos. Arquitectura modular (skimmer, sensores, micro-dragado) seg\u00fan sitio. Marinas/hoteles que cuidan la experiencia visual del visitante. Servicio integral: recolecci\u00f3n + disposici\u00f3n y mantenimiento con OPEX bajo. Pilotos en 1 semana (despliegue \u00e1gil) + panel web/API para gesti\u00f3n y trazabilidad. Universidades/labs ambientales que requieren campa\u00f1as de monitoreo con evidencia."},{"location":"Proyectos4/RANA/#value-proposition","title":"VALUE PROPOSITION","text":"<p>RANA mantiene limpios los cuerpos de agua con navegaci\u00f3n asistida y entrega evidencia medible (kg recolectados, m\u00b2 cubiertos, turbidez) para reducir quejas y justificar presupuesto\u00a0con\u00a0datos.**eros, coordinados para dise\u00f1o, construcci\u00f3n y pruebas. |</p> Categor\u00eda Respuesta Oferta - Robot acu\u00e1tico peque\u00f1o, f\u00e1cil de armar y operar, que limpia basura flotante en estanques o lagos peque\u00f1os. - Incluye sensores b\u00e1sicos para monitoreo de calidad del agua (nivel de agua, turbidez, temperatura). Propuesta de valor - Limpieza r\u00e1pida y econ\u00f3mica de cuerpos de agua peque\u00f1os. - Monitoreo b\u00e1sico del agua para investigaci\u00f3n o proyectos ambientales. - F\u00e1cil de usar y mantener, ideal para estudiantes o comunidades peque\u00f1as. Modelo de ingresos y precio - Financiamiento universitario o becas para prototipos. - Participaci\u00f3n en concursos de innovaci\u00f3n o proyectos ambientales con premios. - Venta simb\u00f3lica de prototipos a laboratorios o grupos estudiantiles, cubriendo solo costos de materiales. Costos - Componentes electr\u00f3nicos b\u00e1sicos: Arduino/Raspberry Pi, motores, sensores, bater\u00edas. - Materiales para flotadores y estructura del robot. - Ensamblaje, pruebas y mantenimiento del prototipo. - Materiales de difusi\u00f3n y capacitaci\u00f3n (presentaciones, carteles, redes). Canales - Presentaciones en la universidad o laboratorios. - Redes sociales o blog del proyecto para mostrar resultados. - Ferias estudiantiles de innovaci\u00f3n o medio ambiente. - Pruebas y demostraciones directas en estanques o laboratorios. Socios - Profesores y compa\u00f1eros que asesoren en dise\u00f1o y pruebas. - Laboratorios universitarios para construcci\u00f3n y testeo. - Proveedores de componentes accesibles. - Comunidades que permitan probar el robot en sus estanques."},{"location":"Sistemas/Examen1/","title":"Examen 1: Sim\u00f3n dice","text":""},{"location":"Sistemas/Examen1/#que-debe-hacer","title":"Que debe hacer:","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <p>La secuencia crece +1 por ronda, de 1 hasta 15.</p> <p>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.</p> <p>Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s).</p> <p>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> <p>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p>"},{"location":"Sistemas/Examen1/#reglas-del-juego","title":"Reglas del juego","text":"<p>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> <p>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> <p>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> <p>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> <p>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> <p>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p>"},{"location":"Sistemas/Examen1/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/timer.h\"\n#include &lt;stdlib.h&gt;\n\n\n#define LED_RED    0\n#define LED_GREEN  1\n#define LED_BLUE   2\n#define LED_YELLOW 3\n\n#define BTN_RED    4\n#define BTN_GREEN  5\n#define BTN_BLUE   6\n#define BTN_YELLOW 7\n\n#define SEG_A 8\n#define SEG_B 9\n#define SEG_C 10\n#define SEG_D 11\n#define SEG_E 12\n#define SEG_F 13\n#define SEG_G 14\n#define SEG_DP 15\n\n#define MAX_RONDA 15\n\n//Estado del juego\nuint8_t secuencia[MAX_RONDA];  //secuencia de colores (0\u20133)\nuint8_t ronda_actual = 0;\n\n//Mapeo de LEDs y botones\nconst uint8_t leds[4] = {LED_RED, LED_GREEN, LED_BLUE, LED_YELLOW};\nconst uint8_t botones[4] = {BTN_RED, BTN_GREEN, BTN_BLUE, BTN_YELLOW};\n\n//Tabla de 7 segmentos (0\u2013F)\nconst uint8_t tabla7seg[16] = {\n    0b0111111, // 0\n    0b0000110, // 1\n    0b1011011, // 2\n    0b1001111, // 3\n    0b1100110, // 4\n    0b1101101, // 5\n    0b1111101, // 6\n    0b0000111, // 7\n    0b1111111, // 8\n    0b1101111, // 9\n    0b1110111, // A\n    0b1111100, // b\n    0b0111001, // C\n    0b1011110, // d\n    0b1111001, // E\n    0b1110001  // F\n};\n\n//Inicializaci\u00f3n\nvoid init_leds() {\n    for(int i=0;i&lt;4;i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], GPIO_OUT);\n        gpio_put(leds[i],0);\n    }\n}\n\nvoid init_botones() {\n    for(int i=0;i&lt;4;i++) {\n        gpio_init(botones[i]);\n        gpio_set_dir(botones[i], GPIO_IN);\n        gpio_pull_up(botones[i]);\n    }\n}\n\nvoid init_display() {\n    for(int i=SEG_A;i&lt;=SEG_G;i++){\n        gpio_init(i);\n        gpio_set_dir(i, GPIO_OUT);\n        gpio_put(i,0);\n    }\n}\n\n//Mostrar en 7 segmentos\nvoid mostrar_hex(uint8_t val){\n    uint8_t mask = tabla7seg[val &amp; 0x0F];\n    for(int i=0;i&lt;7;i++){\n        gpio_put(SEG_A+i, (mask&gt;&gt;i)&amp;1);\n    }\n}\n\n//Reproducir secuencia\nvoid reproducir_secuencia(uint8_t longitud){\n    for(int i=0;i&lt;longitud;i++){\n        gpio_put(leds[secuencia[i]],1);\n        sleep_ms(500);\n        gpio_put(leds[secuencia[i]],0);\n        sleep_ms(250);\n    }\n}\n\n//Leer entrada del jugador con l\u00edmite de tiempo\nbool leer_entrada(uint8_t ronda){\n    uint32_t inicio = to_us_since_boot(get_absolute_time());\n    uint32_t limite = (ronda + 5) * 1000000u; //tiempo l\u00edmite en \u00b5s\n\n    for(int i = 0; i &lt; ronda; i++){\n        bool respondio = false;\n        while(to_us_since_boot(get_absolute_time()) - inicio &lt; limite){\n            for(int j = 0; j &lt; 4; j++){\n                if(!gpio_get(botones[j])){ //bot\u00f3n presionado\n                    sleep_ms(50); //debouncing\n                    if(!gpio_get(botones[j])){ //sigue presionado\n                        if(j == secuencia[i]){\n                            respondio = true; //fue correcto\n                        } else {\n                            //Bot\u00f3n incorrecto \u2192 Game Over\n                            return false;\n                        }\n\n                        //esperar hasta que TODOS los botones est\u00e9n liberados\n                        bool todos_sueltos = false;\n                        while(!todos_sueltos){\n                            todos_sueltos = true;\n                            for(int k = 0; k &lt; 4; k++){\n                                if(!gpio_get(botones[k])) todos_sueltos = false;\n                            }\n                            sleep_ms(10);\n                        }\n                        break;\n                    }\n                }\n            }\n            if(respondio) break; //salir del while\n        }\n        if(!respondio){\n            //Timeout \u2192 Game Over\n            return false;\n        }\n    }\n    return true; //toda la secuencia correcta\n}\n\n\n//Agregar nuevo color aleatorio\nvoid agregar_color(){\n    secuencia[ronda_actual] = rand()%4;\n    ronda_actual++;\n}\n\n//Main\nint main(){\n    stdio_init_all();\n    init_leds();\n    init_botones();\n    init_display();\n    mostrar_hex(0); //espera de inicio\n\n    while(true){\n        //esperar bot\u00f3n para iniciar\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n\n        ronda_actual=0;\n        srand(to_us_since_boot(get_absolute_time())); // semilla aleatoria\n        agregar_color(); //primer color\n\n       while(ronda_actual &lt;= MAX_RONDA){\n    mostrar_hex(ronda_actual);\n    reproducir_secuencia(ronda_actual);\n\n    if(!leer_entrada(ronda_actual)){\n        //Game Over: reiniciar a estado inicial\n        ronda_actual = 0;\n        mostrar_hex(0);\n\n        //esperar nuevo bot\u00f3n para empezar de cero\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n\n        srand(to_us_since_boot(get_absolute_time())); // nueva semilla\n        agregar_color(); //nueva secuencia desde 1\n        continue; //volver a empezar\n    }\n\n    if(ronda_actual == MAX_RONDA) break; //Ronda 15 completada\n\n    agregar_color(); //siguiente ronda\n}\n\n        //Victoria: parpadear LEDs y mostrar 'F' en 7 segmentos\n        for(int i=0;i&lt;5;i++){\n            for(int j=0;j&lt;4;j++) gpio_put(leds[j],1);\n            mostrar_hex(0xF);\n            sleep_ms(500);\n            for(int j=0;j&lt;4;j++) gpio_put(leds[j],0);\n            mostrar_hex(0);\n            sleep_ms(500);\n        }\n\n        //esperar nuevo bot\u00f3n para empezar de cero\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Sistemas/Examen1/#esquematico-de-conexion","title":"Esquematico de conexion:","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Examen2/","title":"\ud83d\udcda Examen 2","text":""},{"location":"Sistemas/Examen2/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Control de un Servomotor </li> <li>Equipo / Autor(es): Luis Javvier Vega Tello </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 22/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra mi segundo examen sobre el control de Servomotores con comandos.</li> </ul>"},{"location":"Sistemas/Examen2/#control-de-servomotores-con-comandos","title":"Control de Servomotores con comandos","text":"<p>1) Hardware m\u00ednimo</p> <ul> <li> <p>1 \u00d7 servomotor en un pin PWM (50 Hz).</p> </li> <li> <p>3 \u00d7 botones:</p> </li> <li> <p>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</p> </li> <li> <p>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</p> </li> <li> <p>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</p> </li> <li>Pi pico 2</li> </ul> <p>2) Que debe hacer:</p> <p>Modo Entrenamiento</p> <ul> <li> <p>Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p> </li> <li> <p>Borrar (alias: clear, borrar)</p> </li> <li> <p>Sintaxis: Borrar</p> </li> <li> <p>Efecto: elimina la lista completa de posiciones.</p> </li> <li> <p>Respuesta: OK.</p> </li> </ul> <p>Escribir (alias: write, escribir)</p> <ul> <li> <p>Sintaxis: Escribir, v1, v2, ..., vn</p> </li> <li> <p>vi son enteros en 0\u2013180.</p> </li> <li> <p>fecto: sobrescribe la lista con los valores dados en ese orden.</p> </li> <li>Respuesta: OK si todos son v\u00e1lidos y la lisa de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 Error argumento invalido.</li> </ul> <p>Reemplazar (alias: replace, reemplazar)</p> <ul> <li> <p>Sintaxis: Reemplazar, i, v</p> </li> <li> <p>\u00cdndice i en base 1 (1 = primera posici\u00f3n).</p> </li> <li> <p>v en 0\u2013180.</p> </li> <li> <p>Efecto: reemplaza el elemento i por v.</p> </li> <li> <p>Respuesta: OK. Si i no existe \u2192 Error indice invalido. Si v fuera de rango \u2192 Error argumento invalido.</p> </li> </ul> <p>Modo Continuo - Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <ul> <li> <p>Formato: posX: V (por ejemplo, pos1: 90), donde X es base 1.</p> </li> <li> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s Error no hay pos y no mover el servo.</p> </li> <li> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p> </li> </ul> <p>Modo Step - BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> <ul> <li> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> </li> <li> <p>En cada cambio de posici\u00f3n:</p> </li> <li> <p>mover el servo a la posici\u00f3n seleccionada;</p> </li> <li> <p>imprimir posX: V.</p> </li> <li> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir Error no hay pos y no mover el servo.</p> </li> </ul> <p>INFO IMPORTANTE: El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados.</p> <p>3) Codigo: <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;string&gt;\n\nusing namespace std;\n\n//CONFIGURACI\u00d3N UART Y PINES\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n\n#define SERVO_PIN 2\nconst uint BTNMODE = 3;\nconst uint BTNNEXT = 4;\nconst uint BTNPREV = 5;\n\n\nint valores_guardados[3] = {0, 0, 0};\n\n\nvoid borrar_lista() {\n    for (int i = 0; i &lt; 3; i++) valores_guardados[i] = 0;\n    printf(\"Lista borrada.\\n\");\n}\n\nuint16_t angle_to_level(uint16_t angle) {\n    float pulse_us = 1000.0f + (angle * 1000.0f / 180.0f);\n    return (uint16_t)((pulse_us / 20000.0f) * 65535);\n}\n\n// main\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"Modo de entrenamiento activado\\n\");\n    printf(\"Escribe (write), reemplazar(replace), y borrar(clear) para opciones\\n\");\n\n    // Inicializaci\u00f3n UART\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    // PWM (Servo)\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan  = pwm_gpio_to_channel(SERVO_PIN);\n    pwm_set_wrap(slice, 65535);\n    float f_clk = 125000000.0f;\n    float div = f_clk / (50.0f * 65536.0f);\n    pwm_set_clkdiv(slice, div);\n    pwm_set_enabled(slice, true);\n\n    // --- Configuraci\u00f3n de botones ---\n    gpio_init(BTNMODE); gpio_set_dir(BTNMODE, GPIO_IN); gpio_pull_up(BTNMODE);\n    gpio_init(BTNNEXT); gpio_set_dir(BTNNEXT, GPIO_IN); gpio_pull_up(BTNNEXT);\n    gpio_init(BTNPREV); gpio_set_dir(BTNPREV, GPIO_IN); gpio_pull_up(BTNPREV);\n\n    // --- Variables de control ---\n    string mensaje_usb = \"\", mensaje_uart = \"\";\n    int modo_index = 0;\n    int modo_actual = 1;     // 1: write, 2: continuo, 3: step\n    bool btnmode_presionado = false, btnnext_presionado = false, btnprev_presionado = false;\n    bool ciclo_activo = false;\n\n    // ==== BUCLE PRINCIPAL ====\n    while (true) {\n        // --- Lectura USB ---\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    string comando = mensaje_usb;\n\n                    // ---- MODO WRITE ----\n                    if (comando == \"write\" || comando == \"escribir\" || comando == \"Write\" || comando == \"Escribir\") {\n                        printf(\"Ingresa 3 valores separandolas por comas (ej: 10,20,30):\\n\");\n                        string entrada_valores = \"\";\n                        while (true) {\n                            int c2 = getchar_timeout_us(0);\n                            if (c2 != PICO_ERROR_TIMEOUT) {\n                                if (c2 == '\\n' || c2 == '\\r') break;\n                                entrada_valores += (char)c2;\n                            }\n                        }\n\n                        int i = 0; string temp = \"\"; bool error = false; int num_comas = 0;\n                        for (char c : entrada_valores) {\n                            if (c == ',') {\n                                num_comas++;\n                                if (i &lt; 3) {\n                                    int val = stoi(temp);\n                                    if (val &lt; 0 || val &gt; 180) { error = true; break; }\n                                    valores_guardados[i] = val;\n                                    temp = \"\"; i++;\n                                }\n                            } else temp += c;\n                        }\n                        if (!error &amp;&amp; !temp.empty() &amp;&amp; i &lt; 3) {\n                            int val = stoi(temp);\n                            if (val &lt; 0 || val &gt; 180) error = true;\n                            else valores_guardados[i] = val;\n                            i++;\n                        }\n\n                        if (i != 3 || num_comas != 2) printf(\"Error, tienen que ser 3 numeros\\n\");\n                        else if (error) printf(\"Error, valores de 0 a 180\\n\");\n                        else printf(\"Valores guardados: %d, %d, %d\\n\", valores_guardados[0], valores_guardados[1], valores_guardados[2]);\n                    }\n\n                    // ---- MODO CLEAR ----\n                    else if (comando == \"clear\" || comando == \"borrar\" || comando == \"Clear\" || comando == \"Borrar\") {\n                        borrar_lista();\n                    }\n\n                    // ---- MODO REPLACE ----\n                    else if (comando == \"replace\" || comando == \"reemplazar\" || comando == \"Replace\" || comando == \"Reemplazar\") {\n                        printf(\"Formato: Replace:posicion,valor (ej: Replace:1,130)\\n\");\n                        string entrada_replace = \"\";\n                        while (true) {\n                            int c2 = getchar_timeout_us(0);\n                            if (c2 != PICO_ERROR_TIMEOUT) {\n                                if (c2 == '\\n' || c2 == '\\r') break;\n                                entrada_replace += (char)c2;\n                            }\n                        }\n\n                        int pos = -1, val = -1; string temp=\"\"; bool sep=false;\n                        for (char c : entrada_replace) {\n                            if (c == ',' &amp;&amp; !sep) {\n                                pos = stoi(temp)-1; temp=\"\"; sep=true;\n                            } else temp+=c;\n                        }\n                        if (sep &amp;&amp; !temp.empty()) val = stoi(temp);\n\n                        if (pos&lt;0 || pos&gt;2) printf(\"Error: posici\u00f3n inv\u00e1lida\\n\");\n                        else if (val&lt;0 || val&gt;180) printf(\"Error: inv\u00e1lido\\n\");\n                        else {\n                            valores_guardados[pos]=val;\n                            printf(\"Valor reemplazado: pos%d = %d\\n\", pos+1, val);\n                            printf(\"Lista: %d, %d, %d\\n\", valores_guardados[0], valores_guardados[1], valores_guardados[2]);\n                        }\n                    }\n\n                    mensaje_usb=\"\";\n                }\n            } else mensaje_usb += (char)ch;\n        }\n\n        // --- Lectura botones ---\n        bool bmode = gpio_get(BTNMODE)==0, bnext = gpio_get(BTNNEXT)==0, bprev = gpio_get(BTNPREV)==0;\n\n        // ---- Cambio de modo ----\n        if (bprev &amp;&amp; !btnprev_presionado) {\n            modo_actual++;\n            if (modo_actual&gt;3) modo_actual=1;\n            printf(\"Cambio a modo %d\\n\", modo_actual);\n            ciclo_activo = (modo_actual==3);\n            btnprev_presionado=true;\n        } else if (!bprev) btnprev_presionado=false;\n\n        // ---- Modo step ----\n        if (modo_actual==2) {\n            if (bmode &amp;&amp; !btnmode_presionado) {\n                if (modo_index&gt;0) modo_index--;\n                pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[modo_index]));\n                printf(\"Servo a %d\u00b0\\n\", valores_guardados[modo_index]);\n                btnmode_presionado=true;\n            } else if (!bmode) btnmode_presionado=false;\n\n            if (bnext &amp;&amp; !btnnext_presionado) {\n                if (modo_index&lt;2) modo_index++;\n                pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[modo_index]));\n                printf(\"Servo a %d\u00b0\\n\", valores_guardados[modo_index]);\n                btnnext_presionado=true;\n            } else if (!bnext) btnnext_presionado=false;\n        }\n\n        // ---- Modo continuo ----\n        if (modo_actual==3 &amp;&amp; ciclo_activo) {\n            bool vacia = (valores_guardados[0]==0 &amp;&amp; valores_guardados[1]==0 &amp;&amp; valores_guardados[2]==0);\n            if (vacia) {\n                printf(\"Error: no hay lista de valores\\n\");\n                sleep_ms(1500);\n            } else {\n                for (int i=0;i&lt;3;i++) {\n                    pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[i]));\n                    printf(\"pos%d: %d\\n\", i+1, valores_guardados[i]);\n                    for (int t=0;t&lt;15;t++) {\n                        sleep_ms(100);\n                        if (!ciclo_activo) break;\n                    }\n                    if (!ciclo_activo) break;\n                }\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre></p> <p>4) Esquematico de conexion: </p> <p>5) Video:</p>"},{"location":"Sistemas/Tarea1./","title":"T1 Comparaci\u00f3n de microcontroladores","text":"Microcontroladores MSP430F2617TPM ESP32 RP2040 STM32F407VG Perif\u00e9ricos Brown-out Detect/Reset, DMA, POR, PWM, WDT PWM, ADC 12 BITS, DAC 8 BITS PWM, UART, ADC, SPI 3x ADC, 2x DAC, 17x Timers Memoria 92 KB FLASH 4 MB FLASH 2 MB FLASH 1 MB FLASH Ecosistema Familia MSP430 Arduino MicroPython, C/C++ IDE OFICIAL HALL/LL Costos USD 483.04 USD 2 USD 4-10 USD 20-28 Arquitectura N\u00facleo RISC de 16 bits Procesador Xtensa LX6, dual-core, 32 bits RISC ARM Cortex 32 bits ARM Cortex 32 bits Vel. De Trabajo 16 MHz 240 MHz 133 MHz 168 MHz <ol> <li>ESP32: Elegido porque ha sido el \u00fanico con el que he trabajado y no se me hizo muy complicad utilizarlo, aparte de que es muy barato </li> <li>RP2040: Es el segundo con mas memoria FLASH y es compatible con C/C++</li> <li>STM32F407VG: Varios perif\u00e9ricos pero m\u00e1s caro, aparte de que su ecosistema no lo conozco</li> <li>MSP430F2617TPM: Car\u00edsimo, es m\u00e1s limitado con su memoria FLASH</li> </ol>"},{"location":"Sistemas/Tarea2/","title":"T2 Outputs b\u00e1sicos","text":""},{"location":"Sistemas/Tarea2/#contador-binario-de-bits","title":"Contador binario de bits","text":"<p>En 4 LEDS debe mostrarse un contador del 0 al 15 en binario cada segundo</p>"},{"location":"Sistemas/Tarea2/#codigo","title":"C\u00f3digo:","text":"<p><pre><code>include \"pico/stdlib.h\"\ninclude \"hardware/gpio.h\"\n\ndefine A 0\ndefine B 1\ndefine C 2\ndefine D 3\n\nint main() {\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n    while (true) {\n        for (uint8_t i = 0; i &lt; 16; i++) {\n            gpio_put_masked(MASK, i &lt;&lt; A);\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre> </p> <p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea2/#barrido-de-leds","title":"Barrido de leds","text":""},{"location":"Sistemas/Tarea2/#codigo_1","title":"C\u00f3digo:","text":"<p><pre><code>include \"pico/stdli-b.h\"\ninclude \"hardware/gpio.h\"\ndefine A 0  \ndefine B 1  \ndefine C 2  \ndefine D 3\ndefine E 4  \nint main() {\n   const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D) | (1u&lt;&lt;E);\n   gpio_init_mask(MASK);\n   gpio_set_dir_out_masked(MASK);  \n   gpio_clr_mask(MASK);            \n   while (true) {\n       for (int i = 0; i &lt; 5; ++i) {\n           gpio_clr_mask(MASK);                \n           gpio_set_mask(1 &lt;&lt; i);              \n           sleep_ms(300);\n       }\n       for (int i = 3; i &gt; 0; --i) {\n           gpio_clr_mask(MASK);\n           gpio_set_mask(1 &lt;&lt; i);\n           sleep_ms(300);\n       }\n   }\n}\n</code></pre> </p> <p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea2/#secuencia-en-codigo-grey","title":"Secuencia en c\u00f3digo grey","text":""},{"location":"Sistemas/Tarea2/#codigo_2","title":"C\u00f3digo:","text":"<pre><code>include \"pico/stdlib.h\"\ninclude \"hardware/gpio.h\"\n\ndefine LED0 0\ndefine LED1 1\ndefine LED2 2\ndefine LED3 3\n\nuint8_t binario_a_gray(uint8_t num) {\n    return num ^ (num &gt;&gt; 1);\n}\n\nint main() {\n    const uint32_t MASK = (1u&lt;&lt;LED0) | (1u&lt;&lt;LED1) | (1u&lt;&lt;LED2) | (1u&lt;&lt;LED3);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    while (true) {\n        for (uint8_t i = 0; i &lt; 16; i++) {  \n            uint8_t gray = binario_a_gray(i);\n            gpio_put_masked(MASK, gray);\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas/Tarea2/#video-de-muestra","title":"Video de muestra","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea4/","title":"T4 LED Pong","text":""},{"location":"Sistemas/Tarea4/#que-debe-hacer","title":"Que debe hacer:","text":"<p>Se trara de un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p>"},{"location":"Sistemas/Tarea4/#codigo","title":"C\u00f3digo:","text":"<p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_P1 0\n#define L1     1\n#define L2     2\n#define L3     3\n#define L4     4\n#define L5     5\n#define LED_P2 6\n\n#define BTN_L  7\n#define BTN_R  8\n\nvolatile bool golpe_L = false;\nvolatile bool golpe_R = false;\nint pos = L3;\nint dir = 0;\n\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN_L) {\n        if (pos == L1) golpe_L = true;\n        else if (dir == 0) dir = 1;\n    }\n    else if (gpio == BTN_R) {\n        if (pos == L5) golpe_R = true;\n        else if (dir == 0) dir = -1;\n    }\n}\n\nvoid parpadear_led(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid reiniciar_juego(int ganador) {\n    parpadear_led(ganador);\n    pos = L3;\n    gpio_put(L3, 1);\n\n    if (ganador == LED_P2) {\n        dir = 1;\n    } else if (ganador == LED_P1) {\n        dir = -1;\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint32_t MASK = (1u&lt;&lt;LED_P1)|(1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5)|(1u&lt;&lt;LED_P2);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    gpio_init(BTN_L); gpio_set_dir(BTN_L, false); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R, false); gpio_pull_up(BTN_R);\n\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    int pos_anterior = L3;\n    gpio_put(pos_anterior, 1);\n\n    while (true) {\n\n        gpio_put(pos_anterior, 0);\n        gpio_put(pos, 1);\n        pos_anterior = pos;\n\n        sleep_ms(500);\n\n        if (dir == 0) continue;\n\n        if (pos == L1) {\n            if (golpe_L) {\n                dir = 1;\n                golpe_L = false;\n            } else {\n                reiniciar_juego(LED_P2);\n                continue;\n            }\n        } else if (pos == L5) {\n            if (golpe_R) {\n                dir = -1;\n                golpe_R = false;\n            } else {\n                reiniciar_juego(LED_P1);\n                continue;\n            }\n        }\n\n        if (pos == L2 &amp;&amp; golpe_L) {\n            dir = 1;\n            golpe_L = false;\n        } else if (pos == L4 &amp;&amp; golpe_R) {\n            dir = -1;\n            golpe_R = false;\n        }\n\n        pos += dir;\n    }\n}\n</code></pre> </p> <p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea5/","title":"T5 Ejercicios de Medici\u00f3n","text":""},{"location":"Sistemas/Tarea5/#ejercicio-1-medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Ejercicio 1: Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":""},{"location":"Sistemas/Tarea5/#que-debe-hacer","title":"Que debe hacer:","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio: - Periodo promedio y tolerancia. - Jitter pico-a-pico y, si tu equipo lo permite, RMS. - Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s)</p>"},{"location":"Sistemas/Tarea5/#codigo","title":"C\u00f3digo","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     1  // usaremos la alarma 1\n\n// Calcula el n\u00famero de IRQ para esa alarma\n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 100000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas/Tarea5/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas/Tarea5/#muestras-del-osciloscopio","title":"Muestras del osciloscopio","text":""},{"location":"Sistemas/Tarea5/#video-de-muestra","title":"Video de muestra:","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea5/#ejercicio-2-comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Ejercicio 2 Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":""},{"location":"Sistemas/Tarea5/#que-debe-hacer_1","title":"Que debe hacer:","text":"<p>Que debe hacer: _Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <p>Usa rearme acumulativo. Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico. Con el osciloscopio, mide y registra para cada modo: Periodo promedio y desviaci\u00f3n respecto al nominal. Jitter pico-a-pico y/o RMS. Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.(mantener modo \u00b5s).</p>"},{"location":"Sistemas/Tarea5/#codigo_1","title":"C\u00f3digo","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     1  // usaremos la alarma 1\n\n// Calcula el n\u00famero de IRQ para esa alarma\n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 100000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas/Tarea5/#esquematico_1","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas/Tarea5/#muestras-del-osciloscopio_1","title":"Muestras del osciloscopio","text":""},{"location":"Sistemas/Tarea5/#video-de-muestra_1","title":"Video de muestra:","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea6/","title":"T6 Actualizaci\u00f3n LED pong","text":""},{"location":"Sistemas/Tarea6/#ejercicio-1","title":"Ejercicio 1","text":""},{"location":"Sistemas/Tarea6/#que-debe-hacer","title":"Que debe hacer:","text":"<p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. .</p>"},{"location":"Sistemas/Tarea6/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_P1 0\n#define L1     1\n#define L2     2\n#define L3     3\n#define L4     4\n#define L5     5\n#define LED_P2 6\n\n#define BTN_L  7\n#define BTN_R  8\n\nvolatile bool golpe_L = false;\nvolatile bool golpe_R = false;\nint pos = L3;\nint dir = 0;\n\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN_L) {\n        if (pos == L1) golpe_L = true;\n        else if (dir == 0) dir = 1;\n    }\n    else if (gpio == BTN_R) {\n        if (pos == L5) golpe_R = true;\n        else if (dir == 0) dir = -1;\n    }\n}\n\nvoid parpadear_led(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid reiniciar_juego(int ganador) {\n    parpadear_led(ganador);\n    pos = L3;\n    gpio_put(L3, 1);\n\n    if (ganador == LED_P2) {\n        dir = 1;\n    } else if (ganador == LED_P1) {\n        dir = -1;\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint32_t MASK = (1u&lt;&lt;LED_P1)|(1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5)|(1u&lt;&lt;LED_P2);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    gpio_init(BTN_L); gpio_set_dir(BTN_L, false); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R, false); gpio_pull_up(BTN_R);\n\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    int pos_anterior = L3;\n    gpio_put(pos_anterior, 1);\n\n    while (true) {\n\n        gpio_put(pos_anterior, 0);\n        gpio_put(pos, 1);\n        pos_anterior = pos;\n\n        sleep_ms(500);\n\n        if (dir == 0) continue;\n\n        if (pos == L1) {\n            if (golpe_L) {\n                dir = 1;\n                golpe_L = false;\n            } else {\n                reiniciar_juego(LED_P2);\n                continue;\n            }\n        } else if (pos == L5) {\n            if (golpe_R) {\n                dir = -1;\n                golpe_R = false;\n            } else {\n                reiniciar_juego(LED_P1);\n                continue;\n            }\n        }\n\n        if (pos == L2 &amp;&amp; golpe_L) {\n            dir = 1;\n            golpe_L = false;\n        } else if (pos == L4 &amp;&amp; golpe_R) {\n            dir = -1;\n            golpe_R = false;\n        }\n\n        pos += dir;\n    }\n}\n</code></pre>"},{"location":"Sistemas/Tarea6/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas/Tarea6/#video-de-muestra","title":"Video de muestra:","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea6/#ejercicio-2","title":"Ejercicio 2","text":""},{"location":"Sistemas/Tarea6/#que-debe-hacer_1","title":"Que debe hacer:","text":"<p>Modificar su pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay.</p>"},{"location":"Sistemas/Tarea6/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_P1 0\n#define L1     1\n#define L2     2\n#define L3     3\n#define L4     4\n#define L5     5\n#define LED_P2 6\n\n#define BTN_L  7\n#define BTN_R  8\n\nvolatile bool golpe_L = false;\nvolatile bool golpe_R = false;\nint pos = L3;\nint dir = 0;\n\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN_L) {\n        if (pos == L1) golpe_L = true;\n        else if (dir == 0) dir = 1;\n    }\n    else if (gpio == BTN_R) {\n        if (pos == L5) golpe_R = true;\n        else if (dir == 0) dir = -1;\n    }\n}\n\nvoid parpadear_led(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid reiniciar_juego(int ganador) {\n    parpadear_led(ganador);\n    pos = L3;\n    gpio_put(L3, 1);\n\n    if (ganador == LED_P2) {\n        dir = 1;\n    } else if (ganador == LED_P1) {\n        dir = -1;\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint32_t MASK = (1u&lt;&lt;LED_P1)|(1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5)|(1u&lt;&lt;LED_P2);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    gpio_init(BTN_L); gpio_set_dir(BTN_L, false); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R, false); gpio_pull_up(BTN_R);\n\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    int pos_anterior = L3;\n    gpio_put(pos_anterior, 1);\n\n    while (true) {\n\n        gpio_put(pos_anterior, 0);\n        gpio_put(pos, 1);\n        pos_anterior = pos;\n\n        sleep_ms(500);\n\n        if (dir == 0) continue;\n\n        if (pos == L1) {\n            if (golpe_L) {\n                dir = 1;\n                golpe_L = false;\n            } else {\n                reiniciar_juego(LED_P2);\n                continue;\n            }\n        } else if (pos == L5) {\n            if (golpe_R) {\n                dir = -1;\n                golpe_R = false;\n            } else {\n                reiniciar_juego(LED_P1);\n                continue;\n            }\n        }\n\n        if (pos == L2 &amp;&amp; golpe_L) {\n            dir = 1;\n            golpe_L = false;\n        } else if (pos == L4 &amp;&amp; golpe_R) {\n            dir = -1;\n            golpe_R = false;\n        }\n\n        pos += dir;\n    }\n}\n</code></pre>"},{"location":"Sistemas/Tarea6/#esquematico_1","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas/Tarea6/#video-de-muestra_1","title":"Video de muestra:","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea7/","title":"T7","text":""},{"location":"Sistemas/Tarea7/#ejercicio71-pwm","title":"Ejercicio7.1 PWM","text":""},{"location":"Sistemas/Tarea7/#instrucciones","title":"Instrucciones:","text":"<p>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</p> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p> <p>Documentar:</p> <p>Valores de duty usados, con el porque.</p> <p>Circuito</p>"},{"location":"Sistemas/Tarea7/#codigo","title":"Codigo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define PWMA   0  \n#define AIN1   1  \n#define STBY   3  \n#define F_PWM_HZ 2000   \n#define TOP 1023  \n#define BTN_LOW 4\n#define BTN_HIGH 5\n\n#define DUTY_LOW  (TOP*30/100)\n#define DUTY_HIGH (TOP*75/100)\n\nint main() {\n\n    stdio_init_all();\n\n    gpio_init(AIN1);\n\n    gpio_set_dir(AIN1, GPIO_OUT);\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    uint chan  = pwm_gpio_to_channel(PWMA);\n\n    gpio_init(BTN_LOW);\n    gpio_set_dir(BTN_LOW, GPIO_IN);\n    gpio_pull_up(BTN_LOW);\n\n    gpio_init(BTN_HIGH);\n    gpio_set_dir(BTN_HIGH, GPIO_IN);\n    gpio_pull_up(BTN_HIGH);\n\n    float f_clk = 150000000.0f; \n\n    float div = f_clk / (10000 * (TOP + 1));\n\n    pwm_set_clkdiv(slice, div);\n\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n\n    pwm_set_enabled(slice, true);\n\n    while (1) {\n\n     if (!gpio_get(BTN_LOW)) {\n            pwm_set_chan_level(slice, chan, DUTY_LOW);\n        }\n        if (!gpio_get(BTN_HIGH)) {\n            pwm_set_chan_level(slice, chan, DUTY_HIGH);\n        }\n        sleep_ms(50);\n    }\n}\n</code></pre>"},{"location":"Sistemas/Tarea7/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas/Tarea7/#video-de-muestra","title":"Video de muestra:","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/Tarea7/#ejercicio72-melodia-con-buzzer","title":"Ejercicio7.2 Melodia con buzzer","text":""},{"location":"Sistemas/Tarea7/#instrucciones_1","title":"Instrucciones:","text":"<p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdio.h&gt;\n\n#define PIN_BUZZER 0\n#define TOP_PWM 1023\n\n\n#define TEMPO 108\n\n\n#define CLKDIV_MIN 1.0f\n#define CLKDIV_MAX 255.0f\n\n// duty fijo al 50%\n#define DUTY_50 (TOP_PWM/2)\n\ntypedef struct {\n    int frecuencia;   \n    int token;        \n} Nota;\n\n\n// token: 8 = corchea, 4 = negra, 2 = blanca, 1 = redonda. Token negativo = puntillo (1.5\u00d7).\nstatic const Nota melodia[] = {\n    {466, 8}, {466, 8}, {466, 8}, {698, 2}, {1047, 2},\n    {932, 8}, {880, 8}, {784, 8}, {1397, 2}, {1047, 4},\n    {932, 8}, {880, 8}, {784, 8}, {1397, 2}, {1047, 4},\n    {932, 8}, {880, 8}, {932, 8}, {784, 2},\n    {523, 8}, {523, 8}, {523, 8}, {698, 2}, {1047, 2},\n    {932, 8}, {880, 8}, {784, 8}, {1397, 2}, {1047, 4},\n    {932, 8}, {880, 8}, {784, 8}, {1397, 2}, {1047, 4},\n    {932, 8}, {880, 8}, {932, 8}, {784, 2},\n    {523, -8}, {523, 16}, {587, -4}, {587, 8},\n    {932, 8}, {880, 8}, {784, 8}, {698, 8}, {698, 8},\n    {784, 8}, {880, 8}, {784, 4}, {587, 8}, {659, 4},\n    {523, -8}, {523, 16}, {587, -4}, {587, 8},\n    {932, 8}, {880, 8}, {784, 8}, {698, 8}, {1047, -8}, {784, 16}, {784, 2},\n    {0, 8}, {523, 8}, {587, -4}, {587, 8},\n    {932, 8}, {880, 8}, {784, 8}, {698, 8}, {698, 8},\n    {784, 8}, {880, 8}, {784, 4}, {587, 8}, {659, 4},\n    {1047, -8}, {1047, 16}, {1397, 4}, {1245, 8}, {1109, 4},\n    {1047, 8}, {932, 4}, {831, 8}, {784, 4}, {698, 8}, {1047, 1}\n};\n\nstatic const int MELODIA_LEN = sizeof(melodia) / sizeof(melodia[0]);\n\nstatic inline float limitar_f(float v, float minimo, float maximo) {\n    if (v &lt; minimo) return minimo;\n    if (v &gt; maximo) return maximo;\n    return v;\n}\n\nint calcular_duracion_ms(int tempo, int token) {\n\n    float nota_entera = (60000.0f / tempo) * 4.0f;\n    float duracion;\n    if (token &gt; 0) {\n        duracion = nota_entera / (float)token;\n    } else {\n\n        duracion = nota_entera / (float)(-token);\n        duracion *= 1.5f;\n    }\n    return (int)(duracion + 0.5f);\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(PIN_BUZZER, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PIN_BUZZER);\n    uint canal = pwm_gpio_to_channel(PIN_BUZZER);\n    pwm_set_wrap(slice, TOP_PWM);\n    pwm_set_chan_level(slice, canal, 0);\n    pwm_set_enabled(slice, true);\n\n    const int tempo = TEMPO;\n\n    while (true) {\n        for (int i = 0; i &lt; MELODIA_LEN; i++) {\n            int freq = melodia[i].frecuencia;\n            int token = melodia[i].token;\n\n            int notaMs = calcular_duracion_ms(tempo, token);\n\n            if (freq == 0) {\n\n                pwm_set_chan_level(slice, canal, 0);\n                sleep_ms((int)(notaMs * 0.9f));\n\n                sleep_ms((int)(notaMs * 0.1f));\n                continue;\n            }\n\n            const float f_clk = 125000000.0f;\n            float clkdiv = f_clk / ((float)freq * (TOP_PWM + 1));\n            clkdiv = limitar_f(clkdiv, CLKDIV_MIN, CLKDIV_MAX);\n            pwm_set_clkdiv(slice, clkdiv);\n\n            pwm_set_chan_level(slice, canal, DUTY_50);\n\n            sleep_ms((int)(notaMs * 0.9f));\n\n            pwm_set_chan_level(slice, canal, 0);\n            sleep_ms((int)(notaMs * 0.1f));\n        }\n\n\n        sleep_ms(1500);\n    }\n\n    return 0;\n}\n</code></pre> <p></p>"},{"location":"Sistemas/Tarea7/#video-de-muestra_1","title":"Video de muestra:","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/tarea3/","title":"T3 Inputs","text":""},{"location":"Sistemas/tarea3/#3-compuertas-basicas-and-or-xor-con-2-botones","title":"3 compuertas b\u00e1sicas, AND / OR / XOR con 2 botones","text":""},{"location":"Sistemas/tarea3/#que-debe-hacer","title":"Qu\u00e9 debe hacer:","text":"<p>Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p>"},{"location":"Sistemas/tarea3/#codigo-para-compuerta-and","title":"C\u00f3digo: Para compuerta AND","text":"<p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_AND 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A);\n    gpio_set_dir(BTN_A, false);\n    gpio_pull_up(BTN_A);\n\n    gpio_init(BTN_B);\n    gpio_set_dir(BTN_B, false);\n    gpio_pull_up(BTN_B);\n\n    gpio_init(LED_AND);\n    gpio_set_dir(LED_AND, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a &amp;&amp; b;\n\n        gpio_put(LED_AND, result);\n\n        sleep_ms(50);\n    }\n}\n</code></pre> Video demostraci\u00f3n:</p>"},{"location":"Sistemas/tarea3/#codigo-para-compuerta-or","title":"C\u00f3digo: Para compuerta OR","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_OR 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A); gpio_set_dir(BTN_A, false); gpio_pull_up(BTN_A);\n    gpio_init(BTN_B); gpio_set_dir(BTN_B, false); gpio_pull_up(BTN_B);\n\n    gpio_init(LED_OR); gpio_set_dir(LED_OR, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a || b;\n\n        gpio_put(LED_OR, result);\n        sleep_ms(50);\n    }\n}\n</code></pre> <p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/tarea3/#codigo-para-compuerta-xor","title":"C\u00f3digo: Para compuerta XOR","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_XOR 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A); gpio_set_dir(BTN_A, false); gpio_pull_up(BTN_A);\n    gpio_init(BTN_B); gpio_set_dir(BTN_B, false); gpio_pull_up(BTN_B);\n\n    gpio_init(LED_XOR); gpio_set_dir(LED_XOR, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a ^ b;\n\n        gpio_put(LED_XOR, result);\n        sleep_ms(50);\n    }\n}\n</code></pre> <p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/tarea3/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n:","text":"<p>Se us\u00f3 las mismas conexiones para las 3 diferentes compuertas.</p> <p></p>"},{"location":"Sistemas/tarea3/#selector-ciclico-de-4-leds-con-avanceretroceso","title":"Selector c\u00edclico de 4 LEDs con avance/retroceso","text":""},{"location":"Sistemas/tarea3/#que-debe-hacer_1","title":"Que debe hacer:","text":"<p>Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</p>"},{"location":"Sistemas/tarea3/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define BTN_PREV 0      \n#define BTN_NEXT 1    \n#define LED0   2\n#define LED1   3\n#define LED2   4\n#define LED3   5\n\nuint8_t STATE = LED0 - 1;\n\nint main(void) {\n    const uint8_t LEDs_M = (1u &lt;&lt; LED0 | 1u &lt;&lt; LED1 | 1u &lt;&lt; LED2 | 1u &lt;&lt; LED3);\n\n    gpio_init_mask(LEDs_M);\n    gpio_set_dir_out_masked(LEDs_M);\n    gpio_set_mask(LEDs_M);   \n    gpio_clr_mask(LEDs_M);\n\n    gpio_init(BTN_PREV);\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    gpio_init(BTN_NEXT);\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    bool NEXT_PREVSTATE = 1;\n    bool PREV_PREVSTATE = 1;\n\n    while (true) {\n        bool NEXT_STATE = !gpio_get(BTN_NEXT);\n        bool PREV_STATE = !gpio_get(BTN_PREV);\n\n        if (NEXT_STATE &amp;&amp; !NEXT_PREVSTATE) {\n            if (STATE == LED3) {\n                STATE = LED0;\n            } else {\n                STATE ++;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        if (PREV_STATE &amp;&amp; !PREV_PREVSTATE) {\n            if (STATE == LED0) {\n                STATE = LED3;\n            } else {\n                STATE --;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        NEXT_PREVSTATE = NEXT_STATE;\n        PREV_PREVSTATE = PREV_STATE;\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas/tarea3/#esquematico","title":"Esquem\u00e1tico:","text":"<p>Video demostraci\u00f3n:</p>"},{"location":"Sistemas/tarea8/","title":"\ud83d\udcda Tarea 8","text":""},{"location":"Sistemas/tarea8/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: UART </li> <li>Equipo / Autor(es): Luis Javier Vega </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 22/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 2 ejercicios de comunicaci\u00f3n UART entre dos Raspberry Pi Pico 2.</li> </ul>"},{"location":"Sistemas/tarea8/#ejercicio-1","title":"Ejercicio 1","text":"<p>1) Que debe hacer: Encender el led conectado a otra Raspberry mediante un bot\u00f3n conectado a la otra Raspbeerry.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n\n#define UART_ID uart0\n#define BAUD_RATE 9600\n\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n\n#define LED_PIN 15\n#define BUTTON_PIN 16\n\nint main() {\n    stdio_init_all();\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    gpio_init(BUTTON_PIN);\n    gpio_set_dir(BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(BUTTON_PIN);\n\n    bool last_button_state = true;\n    bool led_state = false;\n\n    while (true) {\n        bool button_state = gpio_get(BUTTON_PIN);\n\n        // Si se detecta una pulsaci\u00f3n (de HIGH a LOW)\n        if (last_button_state &amp;&amp; !button_state) {\n            uart_putc(UART_ID, 'T'); // Enviamos el car\u00e1cter 'T' al otro Pico\n            sleep_ms(200); // anti rebote\n        }\n        last_button_state = button_state;\n\n        // Si se recibe un byte por UART\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == 'T') {\n                led_state = !led_state; // Cambiar estado del LED\n                gpio_put(LED_PIN, led_state);\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p>"},{"location":"Sistemas/tarea8/#ejercicio-2","title":"Ejercicio 2","text":"<p>1) Que debe hacer: Encender el led conectado a otra Raspberry mediante un bot\u00f3n y/o un comando en el Serial Monitor conectado a la otra Raspbeerry.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 16\n#define led_PIN 15\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    string c = \"\";\n    string p=\"\";\n    while (true){\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            p+= (char)ch;\n            if(ch=='.' || ch=='\\n'){\n                uart_puts(UART_ID, p.c_str());\n                p=\"\";\n            }\n        }\n        int a;\n        if (gpio_get(button_pin) == 0 &amp;&amp; a == 1) {\n            printf(\"Button pressed!\\n\");\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200);\n        }\n         a= gpio_get(button_pin);\n\n        if (uart_is_readable(uart0)) {\n            char character = uart_getc(uart0);\n            printf(character+\"\\n\");\n            if(character=='\\n' || character=='.'){\n                if (c == \"LEDON\"){\n                    gpio_put(led_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\"){\n                    gpio_put(led_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n                } else if(c==\"Invalid Command\"){\n                    printf(\"Invalid Command\\n\");\n                }\n                else{\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c = \"\";\n                continue;\n            }\n            else{\n                c += character;\n            }\n        }\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: Usamos la misma conexi\u00f3n que en el ejercicio 1 </p> <p>4) Video:</p>"},{"location":"recursos/archivos/comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"recursos/archivos/comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"recursos/archivos/comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"recursos/archivos/comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"recursos/archivos/comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"recursos/archivos/comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"recursos/archivos/comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"recursos/archivos/comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"recursos/archivos/comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"recursos/archivos/comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"recursos/archivos/comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"recursos/archivos/comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"recursos/archivos/comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"recursos/archivos/comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"recursos/archivos/comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"recursos/archivos/comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"recursos/archivos/ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"recursos/archivos/ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"recursos/archivos/ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"recursos/archivos/ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"recursos/archivos/ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"recursos/archivos/ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"recursos/archivos/gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"recursos/archivos/gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"recursos/archivos/gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"recursos/archivos/gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"recursos/archivos/gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"recursos/archivos/gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"recursos/archivos/gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"recursos/archivos/gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}